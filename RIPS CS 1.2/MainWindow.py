# -*- coding: utf-8 -*-
"""
Created on Wed Jun  5 17:46:49 2019
@author: Patrick Lierle

Purpose: to act as the main hub for the RIPS GUI, offering interface to control
motors, filterwheels, and wavelength position, as well as keeping track of a
savefile and initiating the FITS watching process
"""

import tkinter as tk
from tkinter import messagebox, filedialog, ttk, simpledialog
from tkinter.ttk import Progressbar
from threading import Thread
import time
import Savefile as sv
from Curvefit import Curvefit as fit
from EchelleAngleCalculator import EchelleAngleCalculator as EAC
from FITSHandler import Watcher as fits
import FilterEditor
import ConnectionWindow

class MainWindow:
    
    # declare filter wheel options as global so they can be accessed throughout
    global spectralOptions, imagingOptions

    spectralOptions = ["OPEN",
                       "Na I (Omega)",
                       "S II (Custom Sci 2)",
                       "K I (Omega)",
                       "DARK"]
    
    imagingOptions = ["OPEN", 
                      "S II+NDI sandwich", 
                      "ND3", 
                      "ND3+ND1 sandwich", 
                      "DARK"]
    
    
    # check if any motors or filterwheels are moving. founded on the axiom that
    # when a motor is moving its status indicator is yellow. hasn't failed me yet...
    def anythingMoving():
        # cycles through each of the 7 (0-6) status indicators to check its color
        # the [1] is because each status indicator is a tuple (tkImage, "color")
        for i in range(7):
            if statusIndicators[i][1] == "yellow":
                return True
        return False
    
    
    # takes the list of FilterWheel and Motor objects generated by ConnectionWindow
    # to establish connections in the MainWindow
    # connections is of the form [0] = imaging filterwheel, [1] = spectral 
    # filterwheel, [2] is a list of motors, 0 through 4, [3] = installed grating
    def connectDevices(connections):
        # global definition to make the devices accessible throughout the class
        global imagingFW, spectralFW, motors, grating
        # connect filterwheels
        imagingFW = connections[0]
        spectralFW = connections[1]
        # create list of motors, 0: slit width, 1: rotiserizer, 2: spec focus, 
        #                         3: image focus, 4: grating angle
        motors = []
        for i in range(5):
            motors.append(connections[2][i])
        # set the slit width step position to its last position before quit IF 
        # savefile exists
        try:
            motors[3].setCurrentPositionAs(sv.Savefile.readFile
                                          ("saves\\autosave.txt")[3])
        except:
            pass
        # set motor speeds
        motors[3].setVelocityLimit(350)
        motors[1].setVelocityLimit(75000)
        # set grating and update save
        grating = connections[3]
        save.updateGrating(grating)
        
        
    # calibrate the two filter wheels in case of issue (internal xagyl function)
    def calibrateFWs():
        imagingFW.calibrate()
        spectralFW.calibrate()
        
        
    # create menubar with 'File' and 'Configure' for save and configuration options
    def createMenuBar():
        # establish menubar and its two subsidiary drop-downs
        menubar = tk.Menu(window)
        filemenu = tk.Menu(menubar, tearoff=0)
        configmenu = tk.Menu(menubar, tearoff=0)
        
        # add options to filemenu
        filemenu.add_command(label="Save Current Settings", 
                                            command=lambda:save.save())
        filemenu.add_separator()
        filemenu.add_command(label="Restore From Last Autosave", 
                                            command=MainWindow.restoreAutosave)
        filemenu.add_command(label="Restore From File...", 
                                            command=MainWindow.restoreSave)
        filemenu.add_separator()
        filemenu.add_command(label="Clear Saves", command=lambda:
                                            sv.Savefile.clearSaves())
        filemenu.add_command(label="Clear Logs", command=lambda:
                                            sv.Savefile.clearLogs())
            
        # add options to config menu
        configmenu.add_command(label="Calibrate Filter Wheels", 
                               command=MainWindow.calibrateFWs)
        configmenu.add_command(label="Display Grating Voltage", 
                               command=MainWindow.displayGratingVoltage)
        configmenu.add_command(label="Display Spec Focus Voltage", 
                               command=MainWindow.displaySpecFocusVoltage)
        configmenu.add_command(label="Enter Platescale...", 
                               command=MainWindow.enterPlatescale)
        configmenu.add_command(label="Register Pre-Aperture Filter...", 
                               command=MainWindow.registerPrefilter)
        configmenu.add_command(label="Rename Filters...", 
                               command=MainWindow.openFilterEditor)
        configmenu.add_command(label="Get Optimum Echelle Angle...", 
                               command=MainWindow.getEchelleAngle)
        configmenu.add_separator()
        configmenu.add_command(label="Reconnect Devices",
                               command=MainWindow.openConnectionWindow)
        
        # combine menubar and two menus following tk protocol
        menubar.add_cascade(label="File", menu=filemenu)
        menubar.add_cascade(label="Configure", menu=configmenu)
        window.config(menu=menubar)
        
        
    # display safety confirmation dialog box when when quit button is clicked
    def confirmClose():
        if tk.messagebox.askyesno(default="no", icon="warning", message=
                            "Are you sure you want to quit the RIPS Motor " 
                            "Control Panel?", title="Confirm Exit"):
            # closes application
            window.destroy()
            window.quit()
            
    # create a dialog box which contains the average voltage position of the
    # grating angle motor
    def displayGratingVoltage():
        volts = motors[4].getAverageVoltagePosition()
        messagebox.showinfo("Grating Motor Voltage","Current grating angle "
                            "motor position is %.4f volts" % volts)
        
    # create a dialog box which contains the average voltage position of the
    # spectral focus motor
    def displaySpecFocusVoltage():
        volts = motors[0].getAverageVoltagePosition()
        messagebox.showinfo("Spectral Focus Motor Voltage","Current spectral "
                            "focus motor position is %.4f volts" % volts)
            
    # obtain a user-entered platescale for use in fits headers and slit width
    # calculation in arcsec
    def enterPlatescale():
        platescale = simpledialog.askfloat("Enter Platescale...", "Enter "
                                           "platescale in \"/mm",parent=window,
                                           minvalue=0.0, maxvalue=100000.0)
        save.updatePlatescale(platescale)
        
        
    # get the echelle angle for given wavelength with greatest throughput
    def getEchelleAngle():
        # retrieve wavelength from user
        wavelength = simpledialog.askfloat("Enter Wavelength...", "Enter "
                                           "wavelength in angstroms",parent=window)
        # determine angle
        best = EAC.findBestEchelleAngle(wavelength)
        angle = best[0]
        order = best[1]
        messagebox.showinfo("Optimum Echelle Angle","The optimum echelle angle "
                            "for %.1f angstroms is %.4f at order %d" % (wavelength,angle,order))
        
    # go to user-input wavelength and focus the spectrum by calculating a voltage 
    # position for grating angle motor and one for the spectral focus motor
    def goToLine():
        currentVoltage = motors[4].getAverageVoltagePosition()
        motorLastMove = motors[4].lastMove
        
        # calculate an estimate for the current wavelength by using the current
        # voltage and the right curvefit based on the motor's last move
        wavelengthFromBlue = fit.getWavelengthFitFromBlue(currentVoltage, grating)
        wavelengthFromRed = fit.getWavelengthFitFromRed(currentVoltage, grating)
        if motorLastMove > 0:
            currentWavelength = wavelengthFromBlue
        elif motorLastMove < 0:
            currentWavelength = wavelengthFromRed
        else:
            currentWavelength = (wavelengthFromBlue+wavelengthFromRed)/2.0
        
        # read targetwavelength from user entrybox
        targetWavelength = float(targetLineEntry.get())
        print("GOTOLINEcurrent: %f and target: %f" % (currentWavelength,targetWavelength))
        
        # depending on whether moving from blue or red, get the voltage fit 
        # for the target wavelength
        if currentWavelength > targetWavelength:
            estimatedVolt = fit.getVoltageFitFromRed(targetWavelength, grating)
        else: 
            estimatedVolt = fit.getVoltageFitFromBlue(targetWavelength, grating)
        
        # get fit for spectral focus for target wavelength and display it on GUI.
        # the *1000-3000 is the scaling factor the 'steps' GUI value
        targetFocusVoltage = fit.getFocusFit(targetWavelength)
        motorSliders[2].set(targetFocusVoltage*1000-3000)
        MainWindow.setEntryFromSlider(2)
        save.updateMotorSteps(2,motorSliders[2].get())
        
        # update status indicator colors and start progressbar
        MainWindow.startProgressGUI(6,indicator2=1)
        
        # start the motors moving to the estimated grating angle voltage and 
        # focus voltage, then update wavelength textbox once goto thread is done
        goto = Thread(target=motors[4].goToVoltageAndFocus,args=
                   (estimatedVolt, motors[0], targetFocusVoltage, targetWavelength, grating))
        goto.start()
        MainWindow.updateWavelength(thread=goto)
        MainWindow.endProgressGUI(goto,6,indicator2=1)
        
        
    # move grating angle a certain number of steps to change viewed wavelengths
    def moveFrame(i):
        if grating == "First Order":
            # 1024 pixels = 2000 steps
            fullscreen = 2000
        elif grating == "Echelle":
            # 1024 pixels = 2350 steps
            fullscreen = 2450
        
        if i == 0:
            steps = fullscreen / -1.0
        elif i == 1:
            steps = fullscreen / -2.0
        elif i == 2:
            steps = fullscreen / -8.0
        elif i == 3:
            steps = fullscreen / -75.0
        elif i == 4:
            steps = fullscreen / -250.0
        elif i == 5:
            steps = fullscreen / 250.0
        elif i == 6:
            steps = fullscreen / 75.0
        elif i == 7:
            steps = fullscreen / 8.0
        elif i == 8:
            steps = fullscreen / 2.0
        elif i == 9:
            steps = fullscreen 
            
        # start progressbar, update status indicator, and move motor
        MainWindow.startProgressGUI(6)
        move = Thread(target=motors[4].setRelativePosition, args=(steps,))
        move.start()
        # for substantial moves, update wavelength textbox
        if i in {0,1,2,7,8,9}:
            MainWindow.updateWavelength(thread=move)
        MainWindow.endProgressGUI(move,6)
            
    
    # move motor to entry value, set slider to reflect this, and update save
    def moveMotorFromEntry(i):
        # get value from entry, update slider and savefile
        val = int(motorEntries[i].get())
        if not i == 3 or val < motors[i].max:
            motorSliders[i].set(val)
            save.updateMotorSteps(i, val)
        else:
            tk.messagebox.showerror(message="entered value must be less than "
                                    "28000 steps", title="Improper Bounds")
            return False
        
        # instructions for each of the four motors
        if i == 0:
            statusIndicator = 1
            # scale from GUI steps to volts
            val = (val + 3000)/1000
        elif i == 1:
            statusIndicator = 2
            #### PLACEHOLDER FOR ROTISERIZER #####
            val = (val + 3000)/1000
        elif i == 2:
            statusIndicator = 4
            # scale from GUI steps to volts
            val = (val + 2700)/1000
        elif i == 3:
            statusIndicator = 5
            # ensure that if slit is set to 0 or smaller it gets fully shut
            # by going past the estimated closed position
            if val == 0:
                val = -2000
                motorEntries[0].delete(0, 10)
                motorEntries[0].insert(0, 0)
            
        # update status indicators and start progressbar
        MainWindow.startProgressGUI(statusIndicator)
        # keep a list, one thread per motor, so that multiple motors' threads
        # don't cancel each other out
        x = [0,0,0,0]
        x[i] = Thread(target=motors[i].setPosition,args=(val,))
        x[i].start()
        MainWindow.endProgressGUI(x[i],statusIndicator)
        
        
    # move motor to slider value, set entry to reflect this, and update save 
    def moveMotorFromSlider(i):
        # get value from slider, update entry and savefile
        val = motorSliders[i].get()
        motorEntries[i].delete(0, 10)
        motorEntries[i].insert(0, val)
        save.updateMotorSteps(i, val)
        
        # instructions for each of the four motors
        if i == 0:
            statusIndicator = 1
            # scale from GUI steps to volts
            val = (val + 3000)/1000
        elif i == 1:
            statusIndicator = 2
            #### PLACEHOLDER #####
            val = (val + 3000)/1000
        elif i == 2:
            statusIndicator = 4
            # scale from GUI steps to volts
            val = (val + 2700)/1000
        elif i == 3:
            statusIndicator = 5
            # ensure that if slit is set to 0 it gets fully shut by going past 
            # the estimated closed position
            if val == 0:
                val = -2000
        # update status indicators and start progressbar
        MainWindow.startProgressGUI(statusIndicator)
        # keep a list, one thread per motor, so that multiple motors' threads
        # don't cancel each other out
        x = [0,0,0,0]
        x[i] = Thread(target=motors[i].setPosition,args=(val,))
        x[i].start()
        MainWindow.endProgressGUI(x[i],statusIndicator)

        
    # reopen the connection window to update device connections
    def openConnectionWindow():
        window.destroy()
        window.quit()
        connections = ConnectionWindow.run()
        # connections[3] is a variable that tells whether the quit button was
        # pressed on the connection window when it closed
        if not connections[3]:
            MainWindow.run(connections)         
            
    
    # open the filter editor dialogue and update filter options lists
    def openFilterEditor():
        # close main window
        window.destroy()
        window.quit()
        # open filter editor, passing in necessary info
        global imagingOptions, spectralOptions
        newNames = FilterEditor.openDialogue(imagingOptions, spectralOptions,
                            imagingFW.getPosition(), spectralFW.getPosition())
        # if the list is the wrong length (e.g. None) keep current settings
        if len(newNames[0]) == 5:
            imagingOptions = newNames[0]
            spectralOptions = newNames[1]
        MainWindow.build()
            
            
    # takes the list of settings generated by savefile and applies it to motors
    # filterwheels, and GUI
    
    """ ADJUST WITH NEW GUI ARRANGEMENT """
    def parseList(settings):
        # spectral FilterWheel
        specVar.set(settings[1])
        MainWindow.updateSpectralFW(settings[1])
        # imaging FilterWheel
        imgVar.set(settings[2])
        MainWindow.updateImagingFW(settings[2])
        # set motors and sliders and entryboxes and update savefile
        motorSliders[0].set(settings[3])
        motorSliders[3].set(settings[10])
        MainWindow.moveMotorFromSlider(0)
        MainWindow.moveMotorFromSlider(3)
        MainWindow.setEntryFromSlider(0)
        MainWindow.setEntryFromSlider(3)
        save.updateMotorSteps(0,int(settings[3]))
        save.updateMotorSteps(3,int(settings[10]))
        # set grating to right angle
        targetLineEntry.delete(0, 10)
        targetLineEntry.insert(0, settings[12])
        MainWindow.goToLine()
        # update Savefile FilterWheel settings
        save.updateSpectralFilter(settings[1])
        save.updateImagingFilter(settings[2])
        # update Savefile grating last move
        save.updateLastMove(motors[4].lastMove)
        
        
    # update specified status indicator(s) and display progressbar
    def startProgressGUI(indicatorNum, indicator2=None):
        # affix progressbar to window
        probar.grid(row=9, column=1, padx=10, sticky='W')
        # set the statusIndicator tuple to a new yellow tuple
        statusIndicators[indicatorNum][0].configure(image=yellowImg)
        statusIndicators[indicatorNum] = (statusIndicators[indicatorNum][0],"yellow")
        # if the user specified a second indicator, do the same as above
        if not indicator2 == None:
            statusIndicators[indicator2][0].configure(image=yellowImg)
            statusIndicators[indicator2] = (statusIndicators[indicator2][0],"yellow")
        probar.start(7)
        
    # wait for specified thread to finish executing then turn status indicator(s)
    # green and check if progressbar still needs to be running
    def endProgressGUI(thread, indicator, indicator2=None):
        # threaded function so that this happens in the background
        def _endProgressGUI():
            # wait for the end of given process
            while thread.isAlive():
                window.update()
                pass
            # set status indicator to a new green tuple
            statusIndicators[indicator][0].configure(image=greenImg)
            statusIndicators[indicator] = (statusIndicators[indicator][0],"green")
            # if the user specified a second indicator, do the same as above
            if not indicator2 == None:
                statusIndicators[indicator2][0].configure(image=greenImg)
                statusIndicators[indicator2] = (statusIndicators[indicator2][0],"green")
            window.update()
            # if nothing is still in motion, remove progressbar from window
            if not MainWindow.anythingMoving():
                probar.stop()
                probar.grid_forget()
            # update save with the last move of the grating motor
            save.updateLastMove(motors[4].lastMove)
        Thread(target=_endProgressGUI).start()
        
        
    # display the pre-aperture filter last entered by the user within the current
    # session and accept a new user entry
    def registerPrefilter():
        prefilter = simpledialog.askstring("Register Pre-Aperture Filter...", 
                                            "Currently registered: %s\nPlease "
                                            "enter new filter name or enter blank "
                                            "for 'NONE'" % save.prefilter)
        if prefilter == "":
            save.updatePrefilter('NONE')
        elif not prefilter == None:
            save.updatePrefilter(prefilter)
    
        
    # restore GUI and devices to the last known position from autosave.txt
    def restoreAutosave():
        try:
            settings = sv.Savefile.readFile('saves\\autosave.txt')
        except: 
            # if autosave.txt doesn't exist, reset everything to default
            settings = ['NONE','OPEN','OPEN',0,0,0,0,0,0,0,0,0,0,0,0,0,'NONE']
        MainWindow.parseList(settings)
            
        
    # restore GUI and devices to settings from the chosen Savefile
    def restoreSave():
        name = filedialog.askopenfilename(title="Choose a Save File to Restore", 
                                          defaultextension='.txt',parent=window)
        settings = sv.Savefile.readFile(name)
        MainWindow.parseList(settings)
        
    # update entrybox value to that of the slider
    def setEntryFromSlider(i):
        val = motorSliders[i].get()
        motorEntries[i].delete(0, 10)
        motorEntries[i].insert(0, val)
       
        
    # move imaging FilterWheel to new set position and update Savefile
    def updateImagingFW(str):
        save.updateImagingFilter(str)
        MainWindow.startProgressGUI(3)
        # change physical filter
        for i in range(len(imagingOptions)):
            if imagingOptions[i] == str:
                # xagyl indexes from 1 not 0
                imagingFW.setPosition(i+1)
        # keep the status indicator yellow and progressbar going for 6 seconds,
        # the time it would take the wheel to travel its greatest distance
        x = Thread(target=time.sleep,args=(6,))
        x.start()
        MainWindow.endProgressGUI(x,3)
    
    
    # move spectral FilterWheel to new set position and update Savefile
    def updateSpectralFW(str):
        save.updateSpectralFilter(str)
        MainWindow.startProgressGUI(0)
        # change physical filter
        for i in range(len(spectralOptions)):
            if spectralOptions[i] == str:
                # xagyl indexes from 1 not 0
                spectralFW.setPosition(i+1)
        # keep the status indicator yellow and progressbar going for 6 seconds,
        # the time it would take the wheel to travel its greatest distance
        x = Thread(target=time.sleep,args=(6,))
        x.start()
        MainWindow.endProgressGUI(x,0)
    
    
    # update textbox containing current wavelength and savefile once the optionally
    # specified thread has finished executing
    def updateWavelength(thread=None):
        # threaded function so that this happens in the background
        def _updateWavelength():
            # if the user passed a thread wait for it to finish executing
            if not thread == None:
                while thread.isAlive():
                    window.update()
                    pass
            # get the voltage position of the motor and fit it for wavelength
            curVoltage = motors[4].getAverageVoltagePosition()
            wavelengthFitFromRed = fit.getWavelengthFitFromRed(curVoltage, grating)
            wavelengthFitFromBlue = fit.getWavelengthFitFromBlue(curVoltage, grating)
            # ensure lastmove is up to date
            lastMove = motors[4].lastMove
            # based on the last move, decide which fit to use to get wavelength
            if lastMove > 0:
                estimatedWavelength = wavelengthFitFromBlue
            elif lastMove < 0:
                estimatedWavelength = wavelengthFitFromRed
            else:
                estimatedWavelength = (wavelengthFitFromRed+wavelengthFitFromBlue)/2
            # display new wavelength determination on the window and update save
            currentLineText.delete('1.0', tk.END)
            currentLineText.insert('1.0', '~%.f' % estimatedWavelength)
            save.updateWavelength(estimatedWavelength)
        Thread(target=_updateWavelength).start()
        
    # begin watching the selected folder for FITS files, and when they appear,
    # add RIPS info into the headers
    def watchForFITS():
        # ask user to choose a directory
        directory = filedialog.askdirectory(title="Select Camera FITS Save Directory")
        FITSWatchProcess = Thread(target=fits.run,args=(directory,),daemon=True)
        FITSWatchProcess.start()
        
    # set the current position to be zero for a motor
    def zeroMotor(i):
        # set motor position as zero
        motors[i].setPositionAs(0)
        # update GUI
        motorSliders[i].set(0)
        motorEntries[i].delete(0, 10)
        motorEntries[i].insert(0, 0)
        # update savefile
        save.updateMotorSteps(i, 0)
        

    # construct main window GUI and run the show; the big function
    def build():
        
        """
        INTIAL GUI ELEMENTS (WINDOWS, FRAMES, LABELS)
        """
        
        # initialize the tk window
        global window
        window = tk.Tk()
        window.geometry("783x650+550+250")
        window.title("RIPS Control Panel")
        window.wm_iconbitmap("images/ripsbufull.ico")
        window.configure(bg="gray88")
        
        # initialize tk frames for GUI geometry
        wavelengthSection = tk.Frame(window, highlightthickness=3, bg="gray88", highlightcolor="gray70",
                    highlightbackground="gray70", width=450, height=45, pady=3)
        curTarWavelengthSection = tk.Frame(wavelengthSection, bg="gray88", pady=8) 
        frameButtonsSection = tk.Frame(wavelengthSection, bg="gray88", pady=3)
        spacer = tk.Frame(curTarWavelengthSection, bg="gray88", width=60, height=1, pady=3)
        
        # initialize globally available progressbar for later use
        global probar
        s = ttk.Style()
        s.theme_use('clam')
        s.configure("blue.Horizontal.TProgressbar", background='CornflowerBlue', 
                    troughcolor='gray75', relief='raised')
        probar = Progressbar(window,style="blue.Horizontal.TProgressbar",orient="horizontal",
                             length=150,mode='indeterminate')
     
        # initialize tk section headers and labels
        imgLabel = tk.Label(window, text="Imaging Filter Wheel Setting:",
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        specLabel = tk.Label(window, text="Spectral Filter Wheel Setting:", 
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        slitWidthLabel = tk.Label(window, text="Slit Width Adjustment:", 
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        rotiserizerLabel = tk.Label(window, text="Rotiserizer Adjustment:", 
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        spectralFocusLabel = tk.Label(window, text="Spectral Focus Adjustment:", 
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        imagingFocusLabel = tk.Label(window, text="Imaging Focus Adjustment:", 
                    font=("device 10 bold"), relief="raised", bg='gray88', padx=5, pady=5)
        wavelengthSectionLabel = tk.Label(wavelengthSection, text="Spectral Wavelength Adjustment:", 
                    font=("device 10 bold"), relief="raised", bg='gray90', padx=5, pady=5)
        currentLineLabel = tk.Label(curTarWavelengthSection, text="current \u03BB : ", 
                                 bg="gray88")
        targetLineLabel = tk.Label(curTarWavelengthSection, text="target \u03BB : ", 
                                 bg="gray88")
        frameButtonsLabel =  tk.Label(wavelengthSection, text="fine tune "
                                       "wavelength buttons (pixels):", bg='gray88')
        bluerLabel = tk.Label(frameButtonsSection, text="<-- bluer", bg='gray88')
        redderLabel = tk.Label(frameButtonsSection, text="redder -->", bg='gray88')
        
        """
        FILTER WHEEL MENUS
        """
        
        # initialize variables that hold current filter wheel setting for GUI
        global specVar, imgVar
        specVar = tk.StringVar(window)
        imgVar = tk.StringVar(window)
        # set initial position to read-in position of the filter wheels
        curSpecFilter = spectralOptions[spectralFW.getPosition()-1]
        curImgFilter = imagingOptions[imagingFW.getPosition()-1]
        specVar.set(curSpecFilter)
        imgVar.set(curImgFilter)
        # initialize drop-down option menus
        spectralMenu = tk.OptionMenu(window, specVar, *spectralOptions, 
                                     command=MainWindow.updateSpectralFW)
        imagingMenu = tk.OptionMenu(window, imgVar, *imagingOptions, 
                                    command=MainWindow.updateImagingFW)
        spectralMenu.configure(highlightthickness=0)
        imagingMenu.configure(highlightthickness=0)
        # update savefile
        save.updateSpectralFilter(curSpecFilter)
        save.updateImagingFilter(curImgFilter)
        
        """
        FOUR MOTOR BOXES
        """
        
        # initialize lists of entryboxes and sliders for each box
        global motorEntries, motorSliders
        motorEntries = []
        motorSliders = []
        for i in range(4):
            motorEntries.append(tk.Entry(window))
        # the *1000-2700 or *1000-3000 is because of scaling between the min/max
        # which is in volts and the GUI which is in a form of "steps"
        motorSliders.append(tk.Scale(window, from_=motors[0].min*1000-3000, 
                                     to=motors[0].max*1000-3000, length=125, orient="horizontal", 
                                     bg="gray88",highlightthickness=0))
        motorSliders.append(tk.Scale(window, from_=-20480, to=20480, 
                                     length=125, orient="horizontal", bg="gray88",highlightthickness=0))
        motorSliders.append(tk.Scale(window, from_=motors[2].min*1000-2700, 
                                     to=motors[2].max*1000-2700, length=125, orient="horizontal", 
                                     bg="gray88",highlightthickness=0))
        motorSliders.append(tk.Scale(window, from_=0, to=28000, 
                                     length=125, orient="horizontal", bg="gray88",highlightthickness=0))
        
        # set sliders to motor positions and set entries to sliders
        motorSliders[0].set(motors[0].getAverageVoltagePosition()*1000-3000)
        motorSliders[1].set(0)
        motorSliders[2].set(motors[2].getAverageVoltagePosition()*1000-2700)
        motorSliders[3].set(motors[3].pos)
        for i in range(4):
            MainWindow.setEntryFromSlider(i)
            # update savefile
            save.updateMotorSteps(i,motorSliders[i].get())
        
        # initialize lists of motor set buttons for the entries and sliders
        setEntryButtons = []
        setSliderButtons = []
        for i in range(4):
            setEntryButtons.append(tk.Button(window, text="set", 
                            command=lambda i=i: MainWindow.moveMotorFromEntry(i)))
            setSliderButtons.append(tk.Button(window, text="set", 
                            command=lambda i=i: MainWindow.moveMotorFromSlider(i)))
        
        # initialize a list of zeroing "tare" buttons for each motor
        zeroButtons = []
        for i in range(4):
            zeroButtons.append(tk.Button(window, text='\u00D8', 
                               command=lambda i=i: MainWindow.zeroMotor(i)))
            
        """
        WAVELENGTH SECTION
        """
            
        # initialize GUI elements for wavelength section
        global currentLineText, targetLineEntry
        currentLineText = tk.Text(curTarWavelengthSection, height=1, width=16, 
                                  bg='gray88')
        targetLineEntry = tk.Entry(curTarWavelengthSection)
        goButton = tk.Button(curTarWavelengthSection, text="go to", 
                               command=MainWindow.goToLine)

        # initialize frame adjustment buttons
        frameButtons = []
        for i in range(10):
            frameButtons.append(tk.Button(frameButtonsSection, 
                               command=lambda i=i: MainWindow.moveFrame(i)))
        frameButtons[0].configure(text="-1024")
        frameButtons[1].configure(text="-512")
        frameButtons[2].configure(text="-128")
        frameButtons[3].configure(text="-10")
        frameButtons[4].configure(text="-1")
        frameButtons[5].configure(text="+1")
        frameButtons[6].configure(text="+10")
        frameButtons[7].configure(text="+128")
        frameButtons[8].configure(text="+512")
        frameButtons[9].configure(text="+1024")

        """
        ADDITIONAL GUI ELEMENTS
        """
        
        # create horizontal menubar for save and configuration options
        MainWindow.createMenuBar()
        
        # initialize quit button to close program
        quitButton = tk.Button(window, text="quit", 
                               command=MainWindow.confirmClose)
        
        # initialize images to be used for status indicators
        # subsample sizes images down
        global statusIndicators, greenImg, yellowImg, redImg
        greenImg = tk.PhotoImage(file='images/green.png').subsample(11)
        yellowImg = tk.PhotoImage(file='images/yellow.png').subsample(11)
        redImg = tk.PhotoImage(file='images/red.png').subsample(11)
        # creates a list of 7 status indicators representing: specFW, slit, rot,
        #                          imgFW, specFoc, imgFoc, grating, respectively
        statusIndicators = []
        for i in range(6):
            statusIndicators.append((tk.Label(window, image=greenImg, bg='gray88'),"green"))
        statusIndicators.append((tk.Label(wavelengthSection, image=greenImg, bg='gray88'),"green"))
        
        
        """
        GRAPHICS GRIDDING
        """
       
        # display frames
        wavelengthSection.grid(row=8, column=1, padx=5, pady=5, columnspan=5, sticky='NW')
        curTarWavelengthSection.grid(row=2, column=1, padx=20, pady=10)
        frameButtonsSection.grid(row=4, column=1, padx=20, pady=10)
        
        # display headers/labels
        specLabel.grid(row=1, column=1, padx=10)
        imgLabel.grid(row=5, column=1, padx=10)
        slitWidthLabel.grid(row=5, column=4, padx=10)
        rotiserizerLabel.grid(row=1, column=4, padx=10)
        spectralFocusLabel.grid(row=1, column=2, padx=10)
        imagingFocusLabel.grid(row=5, column=2, padx=10)
        wavelengthSectionLabel.grid(row=1, column=1, padx=10, pady=10,sticky='W')
        currentLineLabel.grid(row=2, column=1, padx=15, sticky='W')
        targetLineLabel.grid(row=2, column=4, padx=15)
        spacer.grid(row=2, column=3, padx=15, pady=10)
        
        # display filter wheel menus
        spectralMenu.grid(row=2, column=1, padx=20, pady=10)
        imagingMenu.grid(row=6, column=1, padx=20, pady=10)
        
        # display motor box entries, sliders, and buttons
        motorEntries[0].grid(row=2, column=2, padx=20, pady=10)
        motorSliders[0].grid(row=3, column=2, padx=20, pady=10)
        motorEntries[1].grid(row=2, column=4, padx=20, pady=10)
        motorSliders[1].grid(row=3, column=4, padx=20, pady=10)
        motorEntries[2].grid(row=6, column=2, padx=20, pady=10)
        motorSliders[2].grid(row=7, column=2, padx=20, pady=10)
        motorEntries[3].grid(row=6, column=4, padx=20, pady=10)
        motorSliders[3].grid(row=7, column=4, padx=20, pady=10)
        setEntryButtons[0].grid(row=2, column=3, pady=15)
        setSliderButtons[0].grid(row=3, column=3, pady=10)
        setEntryButtons[1].grid(row=2, column=5, pady=15)
        setSliderButtons[1].grid(row=3, column=5, pady=10)
        setEntryButtons[2].grid(row=6, column=3, pady=15)
        setSliderButtons[2].grid(row=7, column=3, pady=10)
        setEntryButtons[3].grid(row=6, column=5, pady=15)
        setSliderButtons[3].grid(row=7, column=5, pady=10)
        zeroButtons[0].grid(row=1, column=3)
        zeroButtons[1].grid(row=1, column=5)
        zeroButtons[2].grid(row=5, column=3)
        zeroButtons[3].grid(row=5, column=5)
        
        # display wavelength section elements
        currentLineText.grid(row=2, column=2, padx=15)
        targetLineEntry.grid(row=2, column=5, padx=15)
        goButton.grid(row=2, column=6, padx=15)
        frameButtonsLabel.grid(row=3, column=1)

        # display frame buttons and red/blue indicators
        bluerLabel.pack(side='left',padx=20,pady=3)
        for i in frameButtons:
            i.pack(side='left',padx=10,pady=3)
        redderLabel.pack(side='left',padx=20,pady=3)
        
        # display quit button
        quitButton.grid(row=9, column=5, padx=10, pady=10)
        
        # display status indicators in green state
        statusIndicators[0][0].grid(row=0, column=1, pady=5)
        statusIndicators[1][0].grid(row=0, column=2, pady=5)
        statusIndicators[2][0].grid(row=0, column=4, pady=5)
        statusIndicators[3][0].grid(row=4, column=1, pady=5)
        statusIndicators[4][0].grid(row=4, column=2, pady=5)
        statusIndicators[5][0].grid(row=4, column=4, pady=5)
        statusIndicators[6][0].grid(row=1, column=1, sticky='E', padx=15)
        
        # color widgets different shades of gray than default
        for i in range(4):
            motorSliders[i].configure(trough='gray75')
            setEntryButtons[i].configure(bg='gray75')
            setSliderButtons[i].configure(bg='gray75')
            zeroButtons[i].configure(bg='white')
        goButton.configure(bg='gray75')
        imagingMenu.configure(bg='gray83')
        spectralMenu.configure(bg='gray83')
        quitButton.configure(bg='gray50', fg = 'white')
        
        # get the last move of the grating motor from the last autosave file
        motors[4].lastMove = int(sv.Savefile.readFile('saves\\autosave.txt')[5])
        # begin watching a specified folder for FITS files
        MainWindow.watchForFITS()
        #ask user to register a pre-aperture filter
        MainWindow.registerPrefilter()
        # show an estimate of where, spectrally, the camera is centered
        MainWindow.updateWavelength()
        
        
        # display everything onscreen
        window.lift()
        window.focus_force()
        window.mainloop()
        
        
    # establishes connection with hardware, creates Savefile, and builds GUI
    def run(cons):
        # initialize a savefile for use throughout class
        global save
        save = sv.Savefile()
        # connect filterwheels and motors
        MainWindow.connectDevices(cons)
        # build the GUI
        MainWindow.build()
        
        
# MainWindow.run()
run = MainWindow.run